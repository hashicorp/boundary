syntax = "proto3";

package controller.api.services.v1;

option go_package = "github.com/hashicorp/boundary/internal/gen/controller/api/services;services";

import "google/protobuf/timestamp.proto";
import "controller/servers/v1/servers.proto";

service WorkerService {
  rpc Status(StatusRequest) returns (StatusResponse) {}
  rpc ValidateSession(ValidateSessionRequest) returns (ValidateSessionResponse) {}
}

message StatusRequest {
  // The worker info. We could use information from the TLS connection but this
  // is easier and going the other route doesn't provide much benefit -- if you
  // get access to the key and spoof the connection, you're already compromised.
  servers.v1.Server worker = 10;

  // Jobs currently active on this worker.
  repeated string active_job_ids = 20;
}

message StatusResponse {
  // Active controllers. This can be used (eventually) for conneciton
  // management.
  repeated servers.v1.Server controllers = 10;

  // Jobs that should be canceled: ones assigned to this worker that have been
  // reported as active but are in canceling state in the database. Once the
  // worker cancels the job, it will no longer show up in active_jobs in the
  // next heartbeat, and we can move the job to canceled state.
  repeated string cancel_job_ids = 20;
}

message ValidateSessionRequest {
  // The session ID from the client
  string id = 10;
}

// SessionResponse contains information necessary for a client to establish a session
message ValidateSessionResponse {
  // ID of the session job
  string id = 10;

  // The scope the job was created in
  string scope_id = 20;

  // The ID of the user that requested the session
  string user_id = 30;

  // Type of the session (e.g. tcp, ssh, etc.)
  string type = 40;

  // The endpoint to connect to, in a manner that makes sense for the type
  string endpoint = 50;

  // The certificate to use when connecting (or if using custom certs, to
  // serve as the "login"). Raw DER bytes.
  bytes certificate = 60;

  // The private key to use when connecting (or if using custom certs, to pass
  // as the "password").
  bytes private_key = 70;

  // After this time the connection will be expired, e.g. forcefully terminated
  google.protobuf.Timestamp expiration_time = 80;

  // Worker information. The first worker in the slice should be prioritized.
  repeated WorkerInfo worker_info = 90;
}

message WorkerInfo {
  // The address of the worker
  string address = 10;
}