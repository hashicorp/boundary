syntax = "proto3";

package controller.api.services.v1;

option go_package = "github.com/hashicorp/watchtower/internal/gen/controller/api/services;services";

service WorkerService {
  rpc Authenticate(WorkerServiceAuthenticateRequest) returns (WorkerServiceAuthenticateResponse) {}
  rpc Status(StatusRequest) returns (StatusResponse) {}
}

message WorkerServiceAuthenticateRequest {
  string name = 10;
  
  // This corresponds to the nonce delivered as part of the encrypted payload.
  // After the session has been established, the first thing that the controller
  // expects is a message that contains that nonce. This requires the submitter
  // of the encrypted connection information to also know a randomly generated
  // value that is inside of it, preventing replay attacks.
  string connection_nonce = 20;
}

message WorkerServiceAuthenticateResponse{
  bool success = 10;
}

message StatusRequest {
  // The name. We could use information from the TLS connection but this is
  // easier and going the other route doesn't provide much benefit -- if you get
  // access to the key and spoof the connection, you're already compromised.
  string name = 10;

  // Jobs currently active on this worker.
  repeated string active_job_ids = 20;
}

message StatusResponse {
  // Jobs that should be canceled: ones assigned to this worker that have been
  // reported as active but are in canceling state in the database. Once the
  // worker cancels the job, it will no longer show up in active_jobs in the
  // next heartbeat, and we can move the job to canceled state.
  repeated string cancel_job_ids = 10;
}