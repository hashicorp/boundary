// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        (unknown)
// source: controller/storage/target/store/v1/target.proto

package store

import (
	timestamp "github.com/hashicorp/boundary/internal/db/timestamp"
	_ "github.com/hashicorp/boundary/sdk/pbs/controller/protooptions"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// TargetView is a view that contains all the target subtypes
type TargetView struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// public_id is used to access the Target via an API
	// @inject_tag: gorm:"primary_key"
	PublicId string `protobuf:"bytes,10,opt,name=public_id,json=publicId,proto3" json:"public_id,omitempty" gorm:"primary_key"`
	// project id for the Target
	// @inject_tag: `gorm:"default:null"`
	ProjectId string `protobuf:"bytes,20,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty" gorm:"default:null"`
	// name is the optional friendly name used to
	// access the Target via an API
	// @inject_tag: `gorm:"default:null"`
	Name string `protobuf:"bytes,30,opt,name=name,proto3" json:"name,omitempty" gorm:"default:null"`
	// description of the Target
	// @inject_tag: `gorm:"default:null"`
	Description string `protobuf:"bytes,40,opt,name=description,proto3" json:"description,omitempty" gorm:"default:null"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime *timestamp.Timestamp `protobuf:"bytes,50,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	// update_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	UpdateTime *timestamp.Timestamp `protobuf:"bytes,60,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty" gorm:"default:current_timestamp"`
	// version allows optimistic locking of the Target when modifying the
	// Target
	// @inject_tag: `gorm:"default:null"`
	Version uint32 `protobuf:"varint,70,opt,name=version,proto3" json:"version,omitempty" gorm:"default:null"`
	// type represents the type of the Target
	// @inject_tag: `gorm:"default:null"`
	Type string `protobuf:"bytes,80,opt,name=type,proto3" json:"type,omitempty" gorm:"default:null"`
	// default port of the Target
	// @inject_tag: `gorm:"default:null"`
	DefaultPort uint32 `protobuf:"varint,90,opt,name=default_port,json=defaultPort,proto3" json:"default_port,omitempty" gorm:"default:null"`
	// Default port for the listening client to use when establishing a session
	// @inject_tag: `gorm:"default:null"`
	DefaultClientPort uint32 `protobuf:"varint,95,opt,name=default_client_port,json=defaultClientPort,proto3" json:"default_client_port,omitempty" gorm:"default:null"`
	// Maximum total lifetime of a created session, in seconds
	// @inject_tag: `gorm:"default:null"`
	SessionMaxSeconds uint32 `protobuf:"varint,100,opt,name=session_max_seconds,json=sessionMaxSeconds,proto3" json:"session_max_seconds,omitempty" gorm:"default:null"`
	// Maximum number of connections in a session
	// @inject_tag: `gorm:"default:null"`
	SessionConnectionLimit int32 `protobuf:"varint,110,opt,name=session_connection_limit,json=sessionConnectionLimit,proto3" json:"session_connection_limit,omitempty" gorm:"default:null"`
	// A boolean expression that allows filtering the workers that can handle a session
	// @inject_tag: `gorm:"default:null"`
	WorkerFilter string `protobuf:"bytes,120,opt,name=worker_filter,json=workerFilter,proto3" json:"worker_filter,omitempty" gorm:"default:null"`
	// @inject_tag: `gorm:"default:null"`
	EgressWorkerFilter string `protobuf:"bytes,130,opt,name=egress_worker_filter,json=egressWorkerFilter,proto3" json:"egress_worker_filter,omitempty" gorm:"default:null"`
	// @inject_tag: `gorm:"default:null"`
	IngressWorkerFilter string `protobuf:"bytes,140,opt,name=ingress_worker_filter,json=ingressWorkerFilter,proto3" json:"ingress_worker_filter,omitempty" gorm:"default:null"`
	// A boolean indicating if session recording has been enabled
	// @inject_tag: `gorm:"default:null"`
	EnableSessionRecording bool `protobuf:"varint,150,opt,name=enable_session_recording,json=enableSessionRecording,proto3" json:"enable_session_recording,omitempty" gorm:"default:null"`
	// PublicId of the storage bucket associated with the target
	// @inject_tag: `gorm:"default:null"`
	StorageBucketId string `protobuf:"bytes,160,opt,name=storage_bucket_id,json=storageBucketId,proto3" json:"storage_bucket_id,omitempty" gorm:"default:null"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TargetView) Reset() {
	*x = TargetView{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetView) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetView) ProtoMessage() {}

func (x *TargetView) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetView.ProtoReflect.Descriptor instead.
func (*TargetView) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{0}
}

func (x *TargetView) GetPublicId() string {
	if x != nil {
		return x.PublicId
	}
	return ""
}

func (x *TargetView) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *TargetView) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TargetView) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *TargetView) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *TargetView) GetUpdateTime() *timestamp.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *TargetView) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TargetView) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *TargetView) GetDefaultPort() uint32 {
	if x != nil {
		return x.DefaultPort
	}
	return 0
}

func (x *TargetView) GetDefaultClientPort() uint32 {
	if x != nil {
		return x.DefaultClientPort
	}
	return 0
}

func (x *TargetView) GetSessionMaxSeconds() uint32 {
	if x != nil {
		return x.SessionMaxSeconds
	}
	return 0
}

func (x *TargetView) GetSessionConnectionLimit() int32 {
	if x != nil {
		return x.SessionConnectionLimit
	}
	return 0
}

func (x *TargetView) GetWorkerFilter() string {
	if x != nil {
		return x.WorkerFilter
	}
	return ""
}

func (x *TargetView) GetEgressWorkerFilter() string {
	if x != nil {
		return x.EgressWorkerFilter
	}
	return ""
}

func (x *TargetView) GetIngressWorkerFilter() string {
	if x != nil {
		return x.IngressWorkerFilter
	}
	return ""
}

func (x *TargetView) GetEnableSessionRecording() bool {
	if x != nil {
		return x.EnableSessionRecording
	}
	return false
}

func (x *TargetView) GetStorageBucketId() string {
	if x != nil {
		return x.StorageBucketId
	}
	return ""
}

type TargetHostSet struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target_id of the TargetHostSet
	// @inject_tag: gorm:"primary_key"
	TargetId string `protobuf:"bytes,10,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"primary_key"`
	// host_set_id of the TargetHostSet
	// @inject_tag: gorm:"primary_key"
	HostSetId string `protobuf:"bytes,20,opt,name=host_set_id,json=hostSetId,proto3" json:"host_set_id,omitempty" gorm:"primary_key"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime    *timestamp.Timestamp `protobuf:"bytes,30,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TargetHostSet) Reset() {
	*x = TargetHostSet{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetHostSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetHostSet) ProtoMessage() {}

func (x *TargetHostSet) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetHostSet.ProtoReflect.Descriptor instead.
func (*TargetHostSet) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{1}
}

func (x *TargetHostSet) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *TargetHostSet) GetHostSetId() string {
	if x != nil {
		return x.HostSetId
	}
	return ""
}

func (x *TargetHostSet) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

type TargetAddress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target_id of the Target
	// @inject_tag: gorm:"primary_key"
	TargetId string `protobuf:"bytes,10,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"primary_key"`
	// address associated to the Target
	// @inject_tag: `gorm:"not_null"`
	Address       string `protobuf:"bytes,20,opt,name=address,proto3" json:"address,omitempty" gorm:"not_null"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TargetAddress) Reset() {
	*x = TargetAddress{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetAddress) ProtoMessage() {}

func (x *TargetAddress) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetAddress.ProtoReflect.Descriptor instead.
func (*TargetAddress) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{2}
}

func (x *TargetAddress) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *TargetAddress) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type CredentialLibrary struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target_id of the Target
	// @inject_tag: gorm:"primary_key"
	TargetId string `protobuf:"bytes,10,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"primary_key"`
	// credential_library_id of the CredentialLibrary
	// @inject_tag: gorm:"primary_key"
	CredentialLibraryId string `protobuf:"bytes,20,opt,name=credential_library_id,json=credentialLibraryId,proto3" json:"credential_library_id,omitempty" gorm:"primary_key"`
	// credential_purpose is the purpose of the credential for the target
	// @inject_tag: gorm:"primary_key"
	CredentialPurpose string `protobuf:"bytes,30,opt,name=credential_purpose,json=credentialPurpose,proto3" json:"credential_purpose,omitempty" gorm:"primary_key"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime    *timestamp.Timestamp `protobuf:"bytes,40,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialLibrary) Reset() {
	*x = CredentialLibrary{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialLibrary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialLibrary) ProtoMessage() {}

func (x *CredentialLibrary) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialLibrary.ProtoReflect.Descriptor instead.
func (*CredentialLibrary) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{3}
}

func (x *CredentialLibrary) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *CredentialLibrary) GetCredentialLibraryId() string {
	if x != nil {
		return x.CredentialLibraryId
	}
	return ""
}

func (x *CredentialLibrary) GetCredentialPurpose() string {
	if x != nil {
		return x.CredentialPurpose
	}
	return ""
}

func (x *CredentialLibrary) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

type StaticCredential struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target_id of the Target
	// @inject_tag: gorm:"primary_key"
	TargetId string `protobuf:"bytes,10,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"primary_key"`
	// credential_id of the static Credential
	// @inject_tag: `gorm:"column:credential_static_id;primary_key"
	CredentialId string `protobuf:"bytes,20,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty" gorm:"column:credential_static_id;primary_key"`
	// credential_purpose is the purpose of the credential for the target
	// @inject_tag: gorm:"primary_key"
	CredentialPurpose string `protobuf:"bytes,30,opt,name=credential_purpose,json=credentialPurpose,proto3" json:"credential_purpose,omitempty" gorm:"primary_key"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime    *timestamp.Timestamp `protobuf:"bytes,40,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StaticCredential) Reset() {
	*x = StaticCredential{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StaticCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StaticCredential) ProtoMessage() {}

func (x *StaticCredential) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StaticCredential.ProtoReflect.Descriptor instead.
func (*StaticCredential) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{4}
}

func (x *StaticCredential) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *StaticCredential) GetCredentialId() string {
	if x != nil {
		return x.CredentialId
	}
	return ""
}

func (x *StaticCredential) GetCredentialPurpose() string {
	if x != nil {
		return x.CredentialPurpose
	}
	return ""
}

func (x *StaticCredential) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

type CredentialSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target_id of the Target
	// @inject_tag: gorm:"primary_key"
	TargetId string `protobuf:"bytes,10,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"primary_key"`
	// credential_source_id of the Credential Library or static Credential
	// @inject_tag: gorm:"primary_key"
	CredentialSourceId string `protobuf:"bytes,20,opt,name=credential_source_id,json=credentialSourceId,proto3" json:"credential_source_id,omitempty" gorm:"primary_key"`
	// credential_purpose is the purpose of the credential for the target
	// @inject_tag: gorm:"primary_key"
	CredentialPurpose string `protobuf:"bytes,30,opt,name=credential_purpose,json=credentialPurpose,proto3" json:"credential_purpose,omitempty" gorm:"primary_key"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime *timestamp.Timestamp `protobuf:"bytes,40,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	// type of credential source (library or static)
	// @inject_tag: `gorm:"not_null"`
	Type          string `protobuf:"bytes,50,opt,name=type,proto3" json:"type,omitempty" gorm:"not_null"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialSource) Reset() {
	*x = CredentialSource{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialSource) ProtoMessage() {}

func (x *CredentialSource) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialSource.ProtoReflect.Descriptor instead.
func (*CredentialSource) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{5}
}

func (x *CredentialSource) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *CredentialSource) GetCredentialSourceId() string {
	if x != nil {
		return x.CredentialSourceId
	}
	return ""
}

func (x *CredentialSource) GetCredentialPurpose() string {
	if x != nil {
		return x.CredentialPurpose
	}
	return ""
}

func (x *CredentialSource) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *CredentialSource) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

type CredentialSourceView struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// public_id of the Credential source
	// @inject_tag: gorm:"primary_key"
	PublicId string `protobuf:"bytes,10,opt,name=public_id,json=publicId,proto3" json:"public_id,omitempty" gorm:"primary_key"`
	// type of credential source (library or static)
	// @inject_tag: `gorm:"not_null"`
	Type          string `protobuf:"bytes,20,opt,name=type,proto3" json:"type,omitempty" gorm:"not_null"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialSourceView) Reset() {
	*x = CredentialSourceView{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialSourceView) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialSourceView) ProtoMessage() {}

func (x *CredentialSourceView) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialSourceView.ProtoReflect.Descriptor instead.
func (*CredentialSourceView) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{6}
}

func (x *CredentialSourceView) GetPublicId() string {
	if x != nil {
		return x.PublicId
	}
	return ""
}

func (x *CredentialSourceView) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

type TargetProxyCertificate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// public_id is used to identify the target proxy key
	// @inject_tag: `gorm:"primary_key"`
	PublicId string `protobuf:"bytes,10,opt,name=public_id,json=publicId,proto3" json:"public_id,omitempty" gorm:"primary_key"`
	// target_id is used to access the proxy target this key is for
	// @inject_tag: `gorm:"not_null"`
	TargetId string `protobuf:"bytes,20,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"not_null"`
	// public_key is the public key associated with this certificate
	// @inject_tag: `gorm:"not_null"`
	PublicKey []byte `protobuf:"bytes,30,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" gorm:"not_null"`
	// private_key is the plaintext key. this is not stored in the db
	// @inject_tag: `gorm:"-" wrapping:"pt,private_key"`
	PrivateKey []byte `protobuf:"bytes,40,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty" gorm:"-" wrapping:"pt,private_key"`
	// private_key_encrypted is the encrypted PEM encoded private key
	// @inject_tag: `gorm:"not_null" wrapping:"ct,private_key"`
	PrivateKeyEncrypted []byte `protobuf:"bytes,50,opt,name=private_key_encrypted,json=privateKeyEncrypted,proto3" json:"private_key_encrypted,omitempty" gorm:"not_null" wrapping:"ct,private_key"`
	// key_id is the kms private id used to encrypt this entry's private key
	// @inject_tag: `gorm:"not_null"`
	KeyId string `protobuf:"bytes,60,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty" gorm:"not_null"`
	// certificate is the PEM encoded certificate
	// @inject_tag: `gorm:"not_null"`
	Certificate []byte `protobuf:"bytes,70,opt,name=certificate,proto3" json:"certificate,omitempty" gorm:"not_null"`
	// not_valid_after is the timestamp at which this certificate's validity period ends
	// @inject_tag: `gorm:"not_null"`
	NotValidAfter *timestamp.Timestamp `protobuf:"bytes,80,opt,name=not_valid_after,json=notValidAfter,proto3" json:"not_valid_after,omitempty" gorm:"not_null"`
	// version allows optimistic locking during modification
	// @inject_tag: `gorm:"default:null"`
	Version uint32 `protobuf:"varint,90,opt,name=version,proto3" json:"version,omitempty" gorm:"default:null"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime *timestamp.Timestamp `protobuf:"bytes,100,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	// update_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	UpdateTime    *timestamp.Timestamp `protobuf:"bytes,110,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty" gorm:"default:current_timestamp"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TargetProxyCertificate) Reset() {
	*x = TargetProxyCertificate{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetProxyCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetProxyCertificate) ProtoMessage() {}

func (x *TargetProxyCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetProxyCertificate.ProtoReflect.Descriptor instead.
func (*TargetProxyCertificate) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{7}
}

func (x *TargetProxyCertificate) GetPublicId() string {
	if x != nil {
		return x.PublicId
	}
	return ""
}

func (x *TargetProxyCertificate) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *TargetProxyCertificate) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *TargetProxyCertificate) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

func (x *TargetProxyCertificate) GetPrivateKeyEncrypted() []byte {
	if x != nil {
		return x.PrivateKeyEncrypted
	}
	return nil
}

func (x *TargetProxyCertificate) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *TargetProxyCertificate) GetCertificate() []byte {
	if x != nil {
		return x.Certificate
	}
	return nil
}

func (x *TargetProxyCertificate) GetNotValidAfter() *timestamp.Timestamp {
	if x != nil {
		return x.NotValidAfter
	}
	return nil
}

func (x *TargetProxyCertificate) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TargetProxyCertificate) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *TargetProxyCertificate) GetUpdateTime() *timestamp.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

type TargetAliasProxyCertificate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// public_id is used to identify the target proxy key
	// @inject_tag: `gorm:"primary_key"`
	PublicId string `protobuf:"bytes,10,opt,name=public_id,json=publicId,proto3" json:"public_id,omitempty" gorm:"primary_key"`
	// target_id is used to access the proxy target this key is for
	// @inject_tag: `gorm:"not_null"`
	TargetId string `protobuf:"bytes,20,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" gorm:"not_null"`
	// public_key is the public key associated with this certificate
	// @inject_tag: `gorm:"not_null"`
	PublicKey []byte `protobuf:"bytes,30,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" gorm:"not_null"`
	// private_key is the plaintext key. this is not stored in the db
	// @inject_tag: `gorm:"-" wrapping:"pt,private_key"`
	PrivateKey []byte `protobuf:"bytes,40,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty" gorm:"-" wrapping:"pt,private_key"`
	// private_key_encrypted is the encrypted PEM encoded private key
	// @inject_tag: `gorm:"not_null" wrapping:"ct,private_key"`
	PrivateKeyEncrypted []byte `protobuf:"bytes,50,opt,name=private_key_encrypted,json=privateKeyEncrypted,proto3" json:"private_key_encrypted,omitempty" gorm:"not_null" wrapping:"ct,private_key"`
	// key_id is the kms private id used to encrypt this entry's private key
	// @inject_tag: `gorm:"not_null"`
	KeyId string `protobuf:"bytes,60,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty" gorm:"not_null"`
	// alias_id is the public id of the alias target
	// @inject_tag: `gorm:"not_null"`
	AliasId string `protobuf:"bytes,70,opt,name=alias_id,json=aliasId,proto3" json:"alias_id,omitempty" gorm:"not_null"`
	// certificate is the PEM encoded certificate
	// @inject_tag: `gorm:"not_null"`
	Certificate []byte `protobuf:"bytes,80,opt,name=certificate,proto3" json:"certificate,omitempty" gorm:"not_null"`
	// not_valid_after is the timestamp at which this certificate's validity period ends
	// @inject_tag: `gorm:"not_null"`
	NotValidAfter *timestamp.Timestamp `protobuf:"bytes,90,opt,name=not_valid_after,json=notValidAfter,proto3" json:"not_valid_after,omitempty" gorm:"not_null"`
	// version allows optimistic locking during modification
	// @inject_tag: `gorm:"default:null"`
	Version uint32 `protobuf:"varint,100,opt,name=version,proto3" json:"version,omitempty" gorm:"default:null"`
	// create_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	CreateTime *timestamp.Timestamp `protobuf:"bytes,110,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty" gorm:"default:current_timestamp"`
	// update_time from the RDBMS
	// @inject_tag: `gorm:"default:current_timestamp"`
	UpdateTime    *timestamp.Timestamp `protobuf:"bytes,120,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty" gorm:"default:current_timestamp"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TargetAliasProxyCertificate) Reset() {
	*x = TargetAliasProxyCertificate{}
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetAliasProxyCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetAliasProxyCertificate) ProtoMessage() {}

func (x *TargetAliasProxyCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_controller_storage_target_store_v1_target_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetAliasProxyCertificate.ProtoReflect.Descriptor instead.
func (*TargetAliasProxyCertificate) Descriptor() ([]byte, []int) {
	return file_controller_storage_target_store_v1_target_proto_rawDescGZIP(), []int{8}
}

func (x *TargetAliasProxyCertificate) GetPublicId() string {
	if x != nil {
		return x.PublicId
	}
	return ""
}

func (x *TargetAliasProxyCertificate) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *TargetAliasProxyCertificate) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *TargetAliasProxyCertificate) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

func (x *TargetAliasProxyCertificate) GetPrivateKeyEncrypted() []byte {
	if x != nil {
		return x.PrivateKeyEncrypted
	}
	return nil
}

func (x *TargetAliasProxyCertificate) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *TargetAliasProxyCertificate) GetAliasId() string {
	if x != nil {
		return x.AliasId
	}
	return ""
}

func (x *TargetAliasProxyCertificate) GetCertificate() []byte {
	if x != nil {
		return x.Certificate
	}
	return nil
}

func (x *TargetAliasProxyCertificate) GetNotValidAfter() *timestamp.Timestamp {
	if x != nil {
		return x.NotValidAfter
	}
	return nil
}

func (x *TargetAliasProxyCertificate) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TargetAliasProxyCertificate) GetCreateTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *TargetAliasProxyCertificate) GetUpdateTime() *timestamp.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

var File_controller_storage_target_store_v1_target_proto protoreflect.FileDescriptor

const file_controller_storage_target_store_v1_target_proto_rawDesc = "" +
	"\n" +
	"/controller/storage/target/store/v1/target.proto\x12\"controller.storage.target.store.v1\x1a*controller/custom_options/v1/options.proto\x1a/controller/storage/timestamp/v1/timestamp.proto\"\xf8\x05\n" +
	"\n" +
	"TargetView\x12\x1b\n" +
	"\tpublic_id\x18\n" +
	" \x01(\tR\bpublicId\x12\x1d\n" +
	"\n" +
	"project_id\x18\x14 \x01(\tR\tprojectId\x12\x12\n" +
	"\x04name\x18\x1e \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18( \x01(\tR\vdescription\x12K\n" +
	"\vcreate_time\x182 \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\x12K\n" +
	"\vupdate_time\x18< \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"updateTime\x12\x18\n" +
	"\aversion\x18F \x01(\rR\aversion\x12\x12\n" +
	"\x04type\x18P \x01(\tR\x04type\x12!\n" +
	"\fdefault_port\x18Z \x01(\rR\vdefaultPort\x12.\n" +
	"\x13default_client_port\x18_ \x01(\rR\x11defaultClientPort\x12.\n" +
	"\x13session_max_seconds\x18d \x01(\rR\x11sessionMaxSeconds\x128\n" +
	"\x18session_connection_limit\x18n \x01(\x05R\x16sessionConnectionLimit\x12#\n" +
	"\rworker_filter\x18x \x01(\tR\fworkerFilter\x121\n" +
	"\x14egress_worker_filter\x18\x82\x01 \x01(\tR\x12egressWorkerFilter\x123\n" +
	"\x15ingress_worker_filter\x18\x8c\x01 \x01(\tR\x13ingressWorkerFilter\x129\n" +
	"\x18enable_session_recording\x18\x96\x01 \x01(\bR\x16enableSessionRecording\x12+\n" +
	"\x11storage_bucket_id\x18\xa0\x01 \x01(\tR\x0fstorageBucketId\"\x99\x01\n" +
	"\rTargetHostSet\x12\x1b\n" +
	"\ttarget_id\x18\n" +
	" \x01(\tR\btargetId\x12\x1e\n" +
	"\vhost_set_id\x18\x14 \x01(\tR\thostSetId\x12K\n" +
	"\vcreate_time\x18\x1e \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\"^\n" +
	"\rTargetAddress\x12\x1b\n" +
	"\ttarget_id\x18\n" +
	" \x01(\tR\btargetId\x120\n" +
	"\aaddress\x18\x14 \x01(\tB\x16\xc2\xdd)\x12\n" +
	"\aaddress\x12\aaddressR\aaddress\"\xe0\x01\n" +
	"\x11CredentialLibrary\x12\x1b\n" +
	"\ttarget_id\x18\n" +
	" \x01(\tR\btargetId\x122\n" +
	"\x15credential_library_id\x18\x14 \x01(\tR\x13credentialLibraryId\x12-\n" +
	"\x12credential_purpose\x18\x1e \x01(\tR\x11credentialPurpose\x12K\n" +
	"\vcreate_time\x18( \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\"\xd0\x01\n" +
	"\x10StaticCredential\x12\x1b\n" +
	"\ttarget_id\x18\n" +
	" \x01(\tR\btargetId\x12#\n" +
	"\rcredential_id\x18\x14 \x01(\tR\fcredentialId\x12-\n" +
	"\x12credential_purpose\x18\x1e \x01(\tR\x11credentialPurpose\x12K\n" +
	"\vcreate_time\x18( \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\"\xf1\x01\n" +
	"\x10CredentialSource\x12\x1b\n" +
	"\ttarget_id\x18\n" +
	" \x01(\tR\btargetId\x120\n" +
	"\x14credential_source_id\x18\x14 \x01(\tR\x12credentialSourceId\x12-\n" +
	"\x12credential_purpose\x18\x1e \x01(\tR\x11credentialPurpose\x12K\n" +
	"\vcreate_time\x18( \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\x12\x12\n" +
	"\x04type\x182 \x01(\tR\x04type\"G\n" +
	"\x14CredentialSourceView\x12\x1b\n" +
	"\tpublic_id\x18\n" +
	" \x01(\tR\bpublicId\x12\x12\n" +
	"\x04type\x18\x14 \x01(\tR\x04type\"\x87\x04\n" +
	"\x16TargetProxyCertificate\x12\x1b\n" +
	"\tpublic_id\x18\n" +
	" \x01(\tR\bpublicId\x12\x1b\n" +
	"\ttarget_id\x18\x14 \x01(\tR\btargetId\x12\x1d\n" +
	"\n" +
	"public_key\x18\x1e \x01(\fR\tpublicKey\x12\x1f\n" +
	"\vprivate_key\x18( \x01(\fR\n" +
	"privateKey\x122\n" +
	"\x15private_key_encrypted\x182 \x01(\fR\x13privateKeyEncrypted\x12\x15\n" +
	"\x06key_id\x18< \x01(\tR\x05keyId\x12 \n" +
	"\vcertificate\x18F \x01(\fR\vcertificate\x12R\n" +
	"\x0fnot_valid_after\x18P \x01(\v2*.controller.storage.timestamp.v1.TimestampR\rnotValidAfter\x12\x18\n" +
	"\aversion\x18Z \x01(\rR\aversion\x12K\n" +
	"\vcreate_time\x18d \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\x12K\n" +
	"\vupdate_time\x18n \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"updateTime\"\xa7\x04\n" +
	"\x1bTargetAliasProxyCertificate\x12\x1b\n" +
	"\tpublic_id\x18\n" +
	" \x01(\tR\bpublicId\x12\x1b\n" +
	"\ttarget_id\x18\x14 \x01(\tR\btargetId\x12\x1d\n" +
	"\n" +
	"public_key\x18\x1e \x01(\fR\tpublicKey\x12\x1f\n" +
	"\vprivate_key\x18( \x01(\fR\n" +
	"privateKey\x122\n" +
	"\x15private_key_encrypted\x182 \x01(\fR\x13privateKeyEncrypted\x12\x15\n" +
	"\x06key_id\x18< \x01(\tR\x05keyId\x12\x19\n" +
	"\balias_id\x18F \x01(\tR\aaliasId\x12 \n" +
	"\vcertificate\x18P \x01(\fR\vcertificate\x12R\n" +
	"\x0fnot_valid_after\x18Z \x01(\v2*.controller.storage.timestamp.v1.TimestampR\rnotValidAfter\x12\x18\n" +
	"\aversion\x18d \x01(\rR\aversion\x12K\n" +
	"\vcreate_time\x18n \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"createTime\x12K\n" +
	"\vupdate_time\x18x \x01(\v2*.controller.storage.timestamp.v1.TimestampR\n" +
	"updateTimeB;Z9github.com/hashicorp/boundary/internal/target/store;storeb\x06proto3"

var (
	file_controller_storage_target_store_v1_target_proto_rawDescOnce sync.Once
	file_controller_storage_target_store_v1_target_proto_rawDescData []byte
)

func file_controller_storage_target_store_v1_target_proto_rawDescGZIP() []byte {
	file_controller_storage_target_store_v1_target_proto_rawDescOnce.Do(func() {
		file_controller_storage_target_store_v1_target_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_controller_storage_target_store_v1_target_proto_rawDesc), len(file_controller_storage_target_store_v1_target_proto_rawDesc)))
	})
	return file_controller_storage_target_store_v1_target_proto_rawDescData
}

var file_controller_storage_target_store_v1_target_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_controller_storage_target_store_v1_target_proto_goTypes = []any{
	(*TargetView)(nil),                  // 0: controller.storage.target.store.v1.TargetView
	(*TargetHostSet)(nil),               // 1: controller.storage.target.store.v1.TargetHostSet
	(*TargetAddress)(nil),               // 2: controller.storage.target.store.v1.TargetAddress
	(*CredentialLibrary)(nil),           // 3: controller.storage.target.store.v1.CredentialLibrary
	(*StaticCredential)(nil),            // 4: controller.storage.target.store.v1.StaticCredential
	(*CredentialSource)(nil),            // 5: controller.storage.target.store.v1.CredentialSource
	(*CredentialSourceView)(nil),        // 6: controller.storage.target.store.v1.CredentialSourceView
	(*TargetProxyCertificate)(nil),      // 7: controller.storage.target.store.v1.TargetProxyCertificate
	(*TargetAliasProxyCertificate)(nil), // 8: controller.storage.target.store.v1.TargetAliasProxyCertificate
	(*timestamp.Timestamp)(nil),         // 9: controller.storage.timestamp.v1.Timestamp
}
var file_controller_storage_target_store_v1_target_proto_depIdxs = []int32{
	9,  // 0: controller.storage.target.store.v1.TargetView.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 1: controller.storage.target.store.v1.TargetView.update_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 2: controller.storage.target.store.v1.TargetHostSet.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 3: controller.storage.target.store.v1.CredentialLibrary.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 4: controller.storage.target.store.v1.StaticCredential.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 5: controller.storage.target.store.v1.CredentialSource.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 6: controller.storage.target.store.v1.TargetProxyCertificate.not_valid_after:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 7: controller.storage.target.store.v1.TargetProxyCertificate.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 8: controller.storage.target.store.v1.TargetProxyCertificate.update_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 9: controller.storage.target.store.v1.TargetAliasProxyCertificate.not_valid_after:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 10: controller.storage.target.store.v1.TargetAliasProxyCertificate.create_time:type_name -> controller.storage.timestamp.v1.Timestamp
	9,  // 11: controller.storage.target.store.v1.TargetAliasProxyCertificate.update_time:type_name -> controller.storage.timestamp.v1.Timestamp
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_controller_storage_target_store_v1_target_proto_init() }
func file_controller_storage_target_store_v1_target_proto_init() {
	if File_controller_storage_target_store_v1_target_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_controller_storage_target_store_v1_target_proto_rawDesc), len(file_controller_storage_target_store_v1_target_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_controller_storage_target_store_v1_target_proto_goTypes,
		DependencyIndexes: file_controller_storage_target_store_v1_target_proto_depIdxs,
		MessageInfos:      file_controller_storage_target_store_v1_target_proto_msgTypes,
	}.Build()
	File_controller_storage_target_store_v1_target_proto = out.File
	file_controller_storage_target_store_v1_target_proto_goTypes = nil
	file_controller_storage_target_store_v1_target_proto_depIdxs = nil
}
