// Code generated by "make migrations"; DO NOT EDIT.
package migrations

var postgresMigrations = map[string]*fakeFile{
	"migrations": {
		name: "migrations",
	},
	"migrations/01_domain_types.down.sql": {
		name: "01_domain_types.down.sql",
		bytes: []byte(`
begin;

drop domain wt_timestamp;
drop domain wt_public_id;
drop function update_time_column() cascade;
drop function immutable_create_time_func() cascade;
commit;

`),
	},
	"migrations/01_domain_types.up.sql": {
		name: "01_domain_types.up.sql",
		bytes: []byte(`
begin;

create domain wt_public_id as text
check(
  length(trim(value)) > 10
);
comment on domain wt_public_id is
'Random ID generated with github.com/hashicorp/vault/sdk/helper/base62';

create domain wt_timestamp as
  timestamp with time zone
  default current_timestamp;
comment on domain wt_timestamp is
'Standard timestamp for all create_time and update_time columns';


CREATE OR REPLACE FUNCTION update_time_column() RETURNS TRIGGER 
SET SCHEMA
  'public' LANGUAGE plpgsql AS $$
BEGIN
   IF row(NEW.*) IS DISTINCT FROM row(OLD.*) THEN
      NEW.update_time = now(); 
      RETURN NEW;
   ELSE
      RETURN OLD;
   END IF;
END;
$$;
comment on function update_time_column() is
'function used in before update triggers to properly set update_time columns';

CREATE
  OR REPLACE FUNCTION immutable_create_time_func() RETURNS TRIGGER
SET SCHEMA
  'public' LANGUAGE plpgsql AS $$
BEGIN IF COALESCE((NEW.create_time <> OLD.create_time), true) THEN
RAISE EXCEPTION 'create_time cannot be set to %', new.create_time;
END IF;
return NEW;
END;
$$;
comment on function immutable_create_time_func() is
'function used in before update triggers to make create_time column immutable';

commit;

`),
	},
	"migrations/02_oplog.down.sql": {
		name: "02_oplog.down.sql",
		bytes: []byte(`
begin;

drop table if exists oplog_entry cascade;

drop trigger if exists update_oplog_entry_update_time on oplog_entry;
drop trigger if exists update_oplog_entry_create_time on oplog_entry;

drop table if exists oplog_ticket cascade;

drop trigger if exists update_oplog_ticket_update_time on oplog_ticket;
drop trigger if exists update_oplog_ticket_create_time on oplog_ticket;

drop table if exists oplog_metadata cascade;

drop trigger if exists update_oplog_metadata_update_time on oplog_metadata;
drop trigger if exists update_oplog_metadata_create_time on oplog_metadata;

commit;
`),
	},
	"migrations/02_oplog.up.sql": {
		name: "02_oplog.up.sql",
		bytes: []byte(`
begin;

CREATE TABLE if not exists oplog_entry (
  id bigint generated always as identity primary key,
  create_time wt_timestamp,
  update_time wt_timestamp,
  version text NOT NULL,
  aggregate_name text NOT NULL,
  "data" bytea NOT NULL
);

CREATE TRIGGER update_oplog_entry_update_time 
BEFORE 
UPDATE ON oplog_entry FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_oplog_entry_create_time
BEFORE
UPDATE ON oplog_entry FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();

CREATE TABLE if not exists oplog_ticket (
  id bigint generated always as identity primary key,
  create_time wt_timestamp,
  update_time wt_timestamp,
  "name" text NOT NULL UNIQUE,
  "version" bigint NOT NULL
);

CREATE TRIGGER update_oplog_ticket_update_time 
BEFORE 
UPDATE ON oplog_ticket FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_oplog_ticket_create_time
BEFORE
UPDATE ON oplog_ticket FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();

CREATE TABLE if not exists oplog_metadata (
  id bigint generated always as identity primary key,
  create_time wt_timestamp,
  entry_id bigint NOT NULL REFERENCES oplog_entry(id) ON DELETE CASCADE ON UPDATE CASCADE,
  "key" text NOT NULL,
  value text NULL
);

CREATE TRIGGER update_oplog_metadata_update_time 
BEFORE 
UPDATE ON oplog_metadata FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_oplog_metadata_create_time
BEFORE
UPDATE ON oplog_metadata FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();

create index if not exists idx_oplog_metatadata_key on oplog_metadata(key);

create index if not exists idx_oplog_metatadata_value on oplog_metadata(value);

INSERT INTO oplog_ticket (name, version)
values
  ('default', 1),
  ('iam_scope', 1),
  ('iam_user', 1),
  ('iam_auth_method', 1),
  ('iam_group', 1),
  ('iam_group_member_user', 1),
  ('iam_role', 1),
  ('iam_role_grant', 1),
  ('iam_role_group', 1),
  ('iam_role_user', 1),
  ('db_test_user', 1),
  ('db_test_car', 1),
  ('db_test_rental', 1);

commit;


`),
	},
	"migrations/03_db.down.sql": {
		name: "03_db.down.sql",
		bytes: []byte(`
begin;

drop table if exists db_test_user;
drop table if exists db_test_car;
drop table if exists db_test_rental;

drop trigger if exists update_db_test_user_update_time on db_test_user;
drop trigger if exists update_db_test_user_create_time on db_test_user;

drop trigger if exists update_db_test_car_update_time on db_test_car;
drop trigger if exists update_db_test_car_create_time on db_test_car;

drop trigger if exists update_db_test_rental_update_time on db_test_rental;
drop trigger if exists update_db_test_rental_create_time on db_test_rental;

commit;

`),
	},
	"migrations/03_db.up.sql": {
		name: "03_db.up.sql",
		bytes: []byte(`
begin;

-- create test tables used in the unit tests for the internal/db package
-- these tables (db_test_user, db_test_car, db_test_rental) are not part
-- of the Watchtower domain model... they are simply used for testing the internal/db package
CREATE TABLE if not exists db_test_user (
  id bigint generated always as identity primary key,
  create_time wt_timestamp,
  update_time wt_timestamp,
  public_id text NOT NULL UNIQUE,
  name text UNIQUE,
  phone_number text,
  email text
);
CREATE TRIGGER update_db_test_user_update_time 
BEFORE 
UPDATE ON db_test_user FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_db_test_user_create_time
BEFORE
UPDATE ON db_test_user FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();

CREATE TABLE if not exists db_test_car (
  id bigint generated always as identity primary key,
  create_time wt_timestamp,
  update_time wt_timestamp,
  public_id text NOT NULL UNIQUE,
  name text UNIQUE,
  model text,
  mpg smallint
);

CREATE TRIGGER update_db_test_car_update_time 
BEFORE 
UPDATE ON db_test_car FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_db_test_car_create_time
BEFORE
UPDATE ON db_test_car FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();

CREATE TABLE if not exists db_test_rental (
  id bigint generated always as identity primary key,
  create_time wt_timestamp,
  update_time wt_timestamp,
  public_id text NOT NULL UNIQUE,
  name text UNIQUE,
  user_id bigint not null REFERENCES db_test_user(id),
  car_id bigint not null REFERENCES db_test_car(id)
);

CREATE TRIGGER update_db_test_rental_update_time 
BEFORE 
UPDATE ON db_test_rental FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_db_test_rental_create_time
BEFORE
UPDATE ON db_test_rental FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();


commit;

`),
	},
	"migrations/04_iam.down.sql": {
		name: "04_iam.down.sql",
		bytes: []byte(`
BEGIN;

drop table if exists iam_scope CASCADE;
drop trigger if exists iam_scope_insert;
drop function if exists iam_sub_scopes_func;

drop trigger if exists update_iam_scope_update_time on iam_scope;
drop trigger if exists update_iam_scope_create_time on iam_scope;

COMMIT;
`),
	},
	"migrations/04_iam.up.sql": {
		name: "04_iam.up.sql",
		bytes: []byte(`
BEGIN;

CREATE TABLE iam_scope_type_enm (
  string text NOT NULL primary key CHECK(string IN ('unknown', 'organization', 'project'))
);
INSERT INTO iam_scope_type_enm (string)
values
  ('unknown'),
  ('organization'),
  ('project');

 
CREATE TABLE iam_scope (
    public_id wt_public_id primary key,
    create_time wt_timestamp,
    update_time wt_timestamp,
    name text,
    type text NOT NULL REFERENCES iam_scope_type_enm(string) CHECK(
      (
        type = 'organization'
        and parent_id = NULL
      )
      or (
        type = 'project'
        and parent_id IS NOT NULL
      )
    ),
    description text,
    parent_id text REFERENCES iam_scope(public_id) ON DELETE CASCADE ON UPDATE CASCADE
  );
create table iam_scope_organization (
    scope_id wt_public_id NOT NULL UNIQUE REFERENCES iam_scope(public_id) ON DELETE CASCADE ON UPDATE CASCADE,
    name text UNIQUE,
    primary key(scope_id)
  );
create table iam_scope_project (
    scope_id wt_public_id NOT NULL REFERENCES iam_scope(public_id) ON DELETE CASCADE ON UPDATE CASCADE,
    parent_id wt_public_id NOT NULL REFERENCES iam_scope_organization(scope_id) ON DELETE CASCADE ON UPDATE CASCADE,
    name text,
    unique(parent_id, name),
    primary key(scope_id, parent_id)
  );


CREATE
  OR REPLACE FUNCTION iam_sub_scopes_func() RETURNS TRIGGER
SET SCHEMA
  'public' LANGUAGE plpgsql AS $$ DECLARE parent_type INT;
BEGIN IF new.type = 'organization' THEN
insert into iam_scope_organization (scope_id, name)
values
  (new.public_id, new.name);
return NEW;
END IF;
IF new.type = 'project' THEN
insert into iam_scope_project (scope_id, parent_id, name)
values
  (new.public_id, new.parent_id, new.name);
return NEW;
END IF;
RAISE EXCEPTION 'unknown scope type';
END;
$$;


CREATE TRIGGER iam_scope_insert
AFTER
insert ON iam_scope FOR EACH ROW EXECUTE PROCEDURE iam_sub_scopes_func();


CREATE
  OR REPLACE FUNCTION iam_immutable_scope_type_func() RETURNS TRIGGER
SET SCHEMA
  'public' LANGUAGE plpgsql AS $$ DECLARE parent_type INT;
BEGIN IF new.type != old.type THEN
RAISE EXCEPTION 'scope type cannot be updated';
END IF;
return NEW;
END;
$$;

CREATE TRIGGER iam_scope_update
BEFORE
update ON iam_scope FOR EACH ROW EXECUTE PROCEDURE iam_immutable_scope_type_func();

CREATE TRIGGER update_iam_scope_update_time 
BEFORE 
UPDATE ON iam_scope FOR EACH ROW EXECUTE PROCEDURE update_time_column();

CREATE TRIGGER update_iam_scope_create_time
BEFORE
UPDATE ON iam_scope FOR EACH ROW EXECUTE PROCEDURE immutable_create_time_func();

COMMIT;

`),
	},
}
