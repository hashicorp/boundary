package job

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/boundary/internal/db"
	"github.com/hashicorp/boundary/internal/db/common"
	"github.com/hashicorp/boundary/internal/errors"
)

// CreateJobRun inserts run into the repository and returns a new JobRun
// containing the run's id, run is not changed. run must not contain
// a id as the id is generated by the database.
//
// run.JobId is required and the private_id of the job this run is executing.
// run.ServerId is required and the private_id of the server assigned to this run.
//
// All options are ignored.
func (r *Repository) CreateJobRun(ctx context.Context, run *JobRun, _ ...Option) (*JobRun, error) {
	const op = "job.(Repository).CreateJobRun"
	if run == nil {
		return nil, errors.New(errors.InvalidParameter, op, "missing job run")
	}
	if run.JobRun == nil {
		return nil, errors.New(errors.InvalidParameter, op, "missing embedded job run")
	}
	if run.JobId == "" {
		return nil, errors.New(errors.InvalidParameter, op, "missing job id")
	}
	if run.ServerId == "" {
		return nil, errors.New(errors.InvalidParameter, op, "missing server id")
	}
	if run.Id != 0 {
		return nil, errors.New(errors.InvalidParameter, op, "id must not be set")
	}

	// Clone run so we do not modify the input
	run = run.clone()

	_, err := r.writer.DoTx(ctx, db.StdRetryCnt, db.ExpBackoff{},
		func(_ db.Reader, w db.Writer) error {
			err := w.Create(ctx, run)
			if err != nil {
				return errors.Wrap(err, op)
			}
			return nil
		},
	)
	if err != nil {
		if errors.IsUniqueError(err) {
			return nil, errors.Wrap(err, op, errors.WithMsg(fmt.Sprintf("job %s already running", run.JobId)))
		}
		return nil, errors.Wrap(err, op)
	}
	return run, nil
}

// UpdateJobRun updates the repository entry for run.Id with the values
// in run for the fields listed in fieldMaskPaths. It returns a new JobRun
// containing the updated values and a count of the number of records
// updated. run is not changed.
//
// run must contain a valid Id. Only run.EndTime, run.TotalCount, run.CompletedCount and
// run.Status can be updated.
//
// All options are ignored.
func (r *Repository) UpdateJobRun(ctx context.Context, run *JobRun, fieldMaskPaths []string, _ ...Option) (*JobRun, int, error) {
	const op = "job.(Repository).UpdateJobRun"
	if run == nil {
		return nil, db.NoRowsAffected, errors.New(errors.InvalidParameter, op, "missing job run")
	}
	if run.JobRun == nil {
		return nil, db.NoRowsAffected, errors.New(errors.InvalidParameter, op, "missing embedded job run")
	}
	if run.Id == 0 {
		return nil, db.NoRowsAffected, errors.New(errors.InvalidParameter, op, "missing id")
	}

	for _, f := range fieldMaskPaths {
		switch {
		case strings.EqualFold("EndTime", f):
		case strings.EqualFold("CompletedCount", f):
		case strings.EqualFold("TotalCount", f):
		case strings.EqualFold("Status", f):
		default:
			return nil, db.NoRowsAffected, errors.New(errors.InvalidFieldMask, op, fmt.Sprintf("invalid field mask: %s", f))
		}
	}
	var dbMask, nullFields []string
	dbMask, nullFields = common.BuildUpdatePaths(
		map[string]interface{}{
			"EndTime":        run.EndTime,
			"CompletedCount": run.CompletedCount,
			"TotalCount":     run.TotalCount,
			"Status":         run.Status,
		},
		fieldMaskPaths,
		nil,
	)
	if len(dbMask) == 0 && len(nullFields) == 0 {
		return nil, db.NoRowsAffected, errors.New(errors.EmptyFieldMask, op, "empty field mask")
	}

	var rowsUpdated int
	run = run.clone()
	_, err := r.writer.DoTx(ctx, db.StdRetryCnt, db.ExpBackoff{},
		func(_ db.Reader, w db.Writer) error {
			var err error
			rowsUpdated, err = w.Update(ctx, run, dbMask, nullFields)
			if err != nil {
				return errors.Wrap(err, op)
			}
			if rowsUpdated > 1 {
				return errors.New(errors.MultipleRecords, op, "more than 1 resource would have been updated")
			}
			return nil
		},
	)
	if err != nil {
		return nil, db.NoRowsAffected, errors.Wrap(err, op)
	}

	return run, rowsUpdated, nil
}

// LookupJobRun will look up a run in the repository. If the run is not
// found, it will return nil, nil.
//
// All options are ignored.
func (r *Repository) LookupJobRun(ctx context.Context, id int64, _ ...Option) (*JobRun, error) {
	const op = "job.(Repository).LookupJobRun"
	if id == 0 {
		return nil, errors.New(errors.InvalidParameter, op, "missing id")
	}

	run := allocJobRun()
	if err := r.reader.LookupWhere(ctx, run, "id = ?", id); err != nil {
		if errors.IsNotFoundError(err) {
			return nil, nil
		}
		return nil, errors.Wrap(err, op, errors.WithMsg(fmt.Sprintf("failed for %d", id)))
	}
	return run, nil
}

// ListJobRuns returns a slice of runs for the jobId.
// WithLimit is the only option supported.
func (r *Repository) ListJobRuns(ctx context.Context, jobId string, opt ...Option) ([]*JobRun, error) {
	const op = "job.(Repository).ListJobRuns"
	if jobId == "" {
		return nil, errors.New(errors.InvalidParameter, op, "missing job id")
	}
	opts := getOpts(opt...)
	limit := r.limit
	if opts.withLimit != 0 {
		// non-zero signals an override of the default limit for the repo.
		limit = opts.withLimit
	}
	var runs []*JobRun
	err := r.reader.SearchWhere(ctx, &runs, "job_id = ?", []interface{}{jobId}, db.WithLimit(limit))
	if err != nil {
		return nil, errors.Wrap(err, op)
	}
	return runs, nil
}

// DeleteJobRun deletes the job for the provided id from the repository
// returning a count of the number of records deleted.
//
// All options are ignored.
func (r *Repository) DeleteJobRun(ctx context.Context, id int64, _ ...Option) (int, error) {
	const op = "job.(Repository).DeleteJobRun"
	if id == 0 {
		return db.NoRowsAffected, errors.New(errors.InvalidParameter, op, "missing id")
	}

	run := allocJobRun()
	var rowsDeleted int
	_, err := r.writer.DoTx(
		ctx, db.StdRetryCnt, db.ExpBackoff{},
		func(_ db.Reader, w db.Writer) (err error) {
			rowsDeleted, err = w.Delete(ctx, run, db.WithWhere("id = ?", id))
			if err != nil {
				return errors.Wrap(err, op)
			}
			if rowsDeleted > 1 {
				return errors.New(errors.MultipleRecords, op, "more than 1 resource would have been deleted")
			}
			return nil
		},
	)
	if err != nil {
		return db.NoRowsAffected, errors.Wrap(err, op, errors.WithMsg(fmt.Sprintf("delete failed for %d", id)))
	}

	return rowsDeleted, nil
}
