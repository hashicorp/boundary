// Package job provides a Job and a JobRun struct suitable for persisting to
// the repository.
//
// A Job represents work that should be run at a predetermined time and needs to be synchronized
// across servers to ensure that one and only one instance of a job is running at any given time.
// The uniqueness of a job is determined by the name and code of the job, this
// uniqueness is enforced by the database.  The private_id (primary key) is generated by the
// repository during CreateJob, and uses the code and name as a seed, this id is prefixed with "job_".
//
// A JobRun represents a single execution of a job, only a single run can be in a
// running state for a specific job.  The private_id (primary key) is generated by the
// repository during FetchWork, this id is prefixed with "jobrun_".
//
// Repository
//
// A repository provides methods for creating, updating, retrieving, and
// deleting Jobs, it also provides methods for fetching, checkpoint and ending JobRuns.
// A new repository should be created for each transaction. For example:
//
//  var wrapper wrapping.Wrapper
//  ... init wrapper ...
//
//  // db implements both the reader and writer interfaces.
//  db, _ := db.Open(db.Postgres, url)
//
//  var j *job.Job
//  j, _ = job.NewJob("name", "code", "description")
//
//  var repo *job.Repository
//  repo, _ = job.NewRepository(db, db, wrapper)
//
//  // insert job into database
//  _, _ = repo.CreateJob(context.Background(), j)
//
//  var run *JobRun
//  repo, _ = job.NewRepository(db, db, wrapper)
//  run, _ = repo.FetchWork(context.Background(), "serverId")
//
//  ... run job ...
//  repo, _ = job.NewRepository(db, db, wrapper)
//  run, _ = repo.CheckpointJobRun(ctx, run, []string{"TotalCount", "CompletedCount"})
//
//  nextJobRun = &timestamp.Timestamp{Timestamp: timestamppb.New(time.Now())}
//
//  repo, _ = job.NewRepository(db, db, wrapper)
//  run, _ = repo.EndJobRun(ctx, run.PrivateId, job.Completed, nextJobRun)
package job
