// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

syntax = "proto3";

option go_package = "github.com/hashicorp/nodeenrollment/types";

package github.com.hashicorp.nodeenrollment.types.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// KEYTYPE is an enum holding known key types
enum KEYTYPE {
  UNSPECIFIED = 0;
  ED25519 = 1;
  X25519 = 2;
}

// CertificateBundle contains information about a certificate the its issuing
// certificate
message CertificateBundle {
  bytes certificate_der = 1 [json_name="certificate_der"];
  bytes ca_certificate_der = 2 [json_name="ca_certificate_der"];
  google.protobuf.Timestamp certificate_not_before = 7 [json_name="certificate_not_before"];
  google.protobuf.Timestamp certificate_not_after = 8 [json_name="certificate_not_after"];
}

// RootCertificate contains information about a root CA certificate and its
// associated public/private keys
message RootCertificate {
  string id = 1; // "current" or "next"
  bytes public_key_pkix = 2 [json_name="public_key_pkix"];
  bytes private_key_pkcs8 = 4 [json_name="private_key_pkcs8"];
  KEYTYPE private_key_type = 5 [json_name="private_key_type"];
  bytes certificate_der = 6 [json_name="certificate_der"];
  google.protobuf.Timestamp not_before = 7 [json_name="not_before"];
  google.protobuf.Timestamp not_after = 8 [json_name="not_after"];
}

// RootCertificates is a message that holds two root certificates for easy
// usage/identification. The ID will always be "roots".
message RootCertificates {
  string id = 1;
  RootCertificate current = 2;
  RootCertificate next = 3;

  // If set, the key ID of the wrapping key used to encrypt the private key
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];

  // State is data that the implementor of a Store can use to round-trip data
  // through this library; as an example, a version number on the resource for
  // implementing transactions.
  google.protobuf.Struct state = 50;
}

// EncryptionKey contains the key information necessary to generate a sharedKey
// NodeInformation and NodeCredentials will store their previous encryption key
// using this message type
message EncryptionKey {
  string key_id = 1 [json_name="key_id"];
  bytes private_key_pkcs8 = 2 [json_name="private_key_pkcs8"];
  KEYTYPE private_key_type = 3 [json_name="private_key_type"];

  bytes public_key_pkix = 4 [json_name="public_key_pkix"];
  KEYTYPE public_key_type = 5 [json_name="public_key_type"];
}

// NodeInformation contains server-side information about a node: its
// certificate public key, any issued certificates (purely for informational
// purposes), its encryption public key and the corresponding server private
// key. Nonce may or may not have a value depending on the flow used to register
// the node and the current state of that flow. The first seen value can be
// useful for display to an operator looking to authorize a node. Authorized
// stores whether or not this node is authorized; technically we could derive
// this based on whether we have complete key/certificate information, but it's
// nice to be explicit.
//
// The ID corresponds to a key identifier generated by this library's
// KeyIdFromPkix function; unlike RootCertificate or NodeCredentials, which will
// only have at most two active values, here we need to identify an incoming
// node's information so use the actual key ID. Rotation simply means a new
// entry will be added with the new ID.
//
// NodeId is an external identifier for this node that does not change
message NodeInformation {
  string id = 1;
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  KEYTYPE certificate_public_key_type = 3 [json_name="certificate_public_key_type"];
  repeated CertificateBundle certificate_bundles = 6 [json_name="certificate_bundles"];
  string node_id = 7 [json_name="node_id"];
  bytes previous_certificate_public_key_pkix = 9 [json_name="previous_certificate_public_key_pkix"];

  bytes encryption_public_key_bytes = 10 [json_name="encryption_public_key_bytes"];
  KEYTYPE encryption_public_key_type = 11 [json_name="encryption_public_key_type"];
  bytes server_encryption_private_key_bytes = 12 [json_name="server_encryption_private_key_bytes"];
  KEYTYPE server_encryption_private_key_type = 13 [json_name="server_encryption_private_key_type"];

  bytes registration_nonce = 20 [json_name="registration_nonce"];
  // This will be populated with with any decrypted values that came in as a
  // result of this flow
  WrappingRegistrationFlowInfo wrapping_registration_flow_info = 22 [json_name="wrapping_registration_flow_info"];

  // If set, the key ID of the wrapping key used to encrypt the private key and
  // the nonce
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];

  // State is data that the implementor of a Store can use to round-trip data
  // through this library; as an example, a version number on the resource for
  // implementing transactions.
  google.protobuf.Struct state = 50;

  EncryptionKey previous_encryption_key = 60 [json_name="previous_encryption_key"];
}

// NodeInformationSet is a message that holds multiple NodeInformation entries
// for a node. This is used to load all valid NodeInformation entries for a node
// from storage and can be used in situations where failover to previous
// credentials is necessary.
//
// NodeId is an external identifier for this node that does not change
message NodeInformationSet {
  string node_id = 7 [json_name="node_id"];
  repeated NodeInformation nodes = 10;
}

// NodeCredentials is the corresponding struct for NodeInformation on the node
// side, containing the values necessary for proving identity. At various points
// in registration/authorization flows this may have some or all fields filled in.
message NodeCredentials {
  string id = 1; // "current" or "next"
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  bytes certificate_private_key_pkcs8 = 4 [json_name="certificate_private_key_pkcs8"];
  KEYTYPE certificate_private_key_type = 5 [json_name="certificate_private_key_type"];
  repeated CertificateBundle certificate_bundles = 6 [json_name="certificate_bundles"];
  bytes previous_certificate_public_key_pkix = 9 [json_name="previous_certificate_public_key_pkix"];

  bytes encryption_private_key_bytes = 10 [json_name="encryption_private_key_bytes"];
  KEYTYPE encryption_private_key_type = 11 [json_name="encryption_private_key_type"];

  bytes server_encryption_public_key_bytes = 12 [json_name="server_encryption_public_key_bytes"];
  KEYTYPE server_encryption_public_key_type = 13 [json_name="server_encryption_public_key_type"];

  bytes registration_nonce = 20 [json_name="registration_nonce"];

  // If set, the key ID of the wrapping key used to encrypt the private keys
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];

  // State is data that the implementor of a Store can use to round-trip data
  // through this library; as an example, a version number on the resource for
  // implementing transactions.
  google.protobuf.Struct state = 50;

  EncryptionKey previous_encryption_key = 60 [json_name="previous_encryption_key"];
}

// WrappingRegistrationFlowInfo is a message that can be encrypted via a shared
// encryption wrapper and supplied to perform just-in-time registration. The
// public key contained in this bundle must match that within
// FetchNodeCredentialsInfo, as must the nonce. Forgeries by other users with
// access to the wrapper are prevented due to the signature on the
// FetchNodeCredentialsRequest including this; replays are prevented because the
// returned credentials are still encrypted to the derived shared key.
//
// The application specific params can be used to pass extra registration
// information to the consuming application. Although both provide state to the
// server, there are two differences between the application specific params and
// passing state through to the node's dialer:
//
// * The information is available at different times; client state cannot be
//   sent through most of the nodeenrollment code because state parameters are
//   reserved for the storage system to use as needed (e.g. to track operations
//   across multiple calls). So client state is only available to the eventual
//   receiver of a connection via a *protocol.Conn, whereas the application
//   specific params are available when node information is being stored (at
//   which time a conn is not available, and where passing this information as
//   state would overwrite the storage system's state, if used).
// * Anything in WrappingRegistrationFlowInfo is encrypted via the KMS, if
//   required
//
// It is entirely possible that the state passed into `protocol.Dial` and
// application specific params will carry the same data for use at different
// times. For instance, information about a node's name and version may be put
// into application specific params in order to have it avaialble during
// registration time, since registration is automatic (as opposed to e.g. an API
// call to activate a worker-led token where name can be provided at that time);
// however, when the connection is eventually returned to the application
// listener, the state can help the application figure out the next step in
// handling the connection based on version (e.g. passing to gRPC versus
// starting a yamux session).
message WrappingRegistrationFlowInfo {
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];

  bytes nonce = 20;

  google.protobuf.Struct application_specific_params = 50;
}

// FetchNodeCredentialsInfo contains the values bundled and signed into a
// FetchNodeCredentialsRequest. These values contain the ID (for identification,
// although the server should always re-derive this itself), the claimed
// certificate public key (which is also used to sign these values), and the
// public encryption key, as well as the registration nonce.
//
// Because the signature from the certificate public key is across both itself
// and the encryption key, if the key ID is authorized, then after verification
// of the signature we can trust the public encryption key too, which is an
// important property for preventing MITM/replay scenarios.
message FetchNodeCredentialsInfo {
  string id = 1; // Key id derived from pkix public key

  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  KEYTYPE certificate_public_key_type = 3 [json_name="certificate_public_key_type"];
  bytes previous_certificate_public_key_pkix = 9 [json_name="previous_certificate_public_key_pkix"];

  bytes encryption_public_key_bytes = 10 [json_name="encryption_public_key_bytes"];
  KEYTYPE encryption_public_key_type = 11 [json_name="encryption_public_key_type"];

  bytes nonce = 20;

  // If provided, a wrapped (encrypted) registration bundle that can be used for
  // just-in-time authorization
  bytes wrapped_registration_info = 21 [json_name="wrapped_registration_info"];
  // This will be populated with decrypted values if the above field is populated
  WrappingRegistrationFlowInfo wrapping_registration_flow_info = 22 [json_name="wrapping_registration_flow_info"];

  google.protobuf.Timestamp not_before = 7 [json_name="not_before"];
  google.protobuf.Timestamp not_after = 8 [json_name="not_after"];
}

// FetchNodeCredentialsRequest contains the marshaled FetchNodeCredentialsInfo
// message and a signature using private key corresponding to the certificate
// public key contained within the marshaled bundle.
message FetchNodeCredentialsRequest {
  bytes bundle = 28;
  bytes bundle_signature = 29 [json_name="bundle_signature"];

  // If an intermediate node is decrypting the wrapped registration info with a
  // wrapper not available on the server, it can't cache the decrypted value in
  // the original bundle because it's signed. In that case, it can cache the
  // value here and encrypt it to the server.
  bytes rewrapped_wrapping_registration_flow_info = 32 [json_name="rewrapped_wrapping_registration_flow_info"];
  string rewrapping_key_id = 33 [json_name="rewrapping_key_id"];
}

// FetchNodeCredentialsResponse contains a response to a fetch request. If
// unauthorized, only that bool will be returned. If authorized, the encrypted
// node credentials will contain a marshaled NodeCredentials struct containing
// certificates and other server-provided information, with the encryption key
// derived from a DH operation on the node's submitted public key and the
// server's private key corresponding to the given public encryption key.
//
// The encrypted node credentials are signed with the current root certificate
// key. This is an optional step that can be taken by the node if it has
// pre-distributed CA certificates to validate the signature on the encrypted
// node credentials. This mostly is a guard against the failure of an operator
// to actually validate the key ID that they are authorizing.
message FetchNodeCredentialsResponse {
  bytes server_encryption_public_key_bytes = 12 [json_name="encryption_public_key_bytes"];
  KEYTYPE server_encryption_public_key_type = 13 [json_name="encryption_public_key_type"];

  bytes encrypted_node_credentials = 40 [json_name="encrypted_node_credentials"];
  bytes encrypted_node_credentials_signature = 41 [json_name="encrypted_node_credentials_signature"];
}

// RotateNodeCredentialsRequest is the message used when a node wants to rotate
// credentials
message RotateNodeCredentialsRequest {
  // For identification of the node, in case it's not trivial from the
  // connection
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];

  // NodeId is an external identifier for this node that does not change
  string node_id = 7 [json_name="node_id"];

  // Encrypted FetchNodeCredentialsRequest, with the current encryption
  // parameters used for key generation
  bytes encrypted_fetch_node_credentials_request = 45 [json_name="encrypted_fetch_node_credentials_request"];
}

// RotateNodeCredentialsResponse is the message used to return values
message RotateNodeCredentialsResponse {
  // Encrypted FetchNodeCredentialsResponse, with the current encryption
  // parameters used for key generation. The new key will be used for the
  // encrypted node credentials in the response.
  bytes encrypted_fetch_node_credentials_response = 45 [json_name="encrypted_fetch_node_credentials_response"];
}


// GenerateServerCertificatesRequest holds values necessary for the server to
// generate a server-side TLS certificate, either for itself or for a middle
// node in a multi-hop scenario. The nonce and signature are provided by the
// authenticating node, so that the server can validate the signature and ensure
// that the node is authorized, then embed the nonce in the returned certificate
// to authorize the upstream node (or server) to the authenticating node.
//
// The common name and skip verification parameters would ideally be options to
// downstream functions, however, since multihop goes over gRPC (or could go
// over some other transport) the options cannot be carried in that way. If
// desired, in the future, an options message could be created and these (and
// any other) values aggregated there.
message GenerateServerCertificatesRequest {
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];

  // NodeId is an external identifier for this node that does not change
  string node_id = 7 [json_name="node_id"];

  bytes nonce = 20;
  bytes nonce_signature = 21 [json_name="nonce_signature"];
  string common_name = 24 [json_name="common_name"];
  bool skip_verification = 25 [json_name="skip_verification"];

  // ClientState data comes from the client and will be returned in the
  // *protocol.Conn, if used. This must be a marshaled structpb.Struct.
  bytes client_state = 50 [json_name="client_state"];
  // ClientStateSignature, like with the nonce, is used to be able to trust the
  // data, once the public key has been validated
  bytes client_state_signature = 51 [json_name="client_state_signature"];
}

// GenerateServerCertificatesResponse contains values for a successful response
// to the request: a private key for the server (or intemediate node) to use
// along with the returned certificates.
message GenerateServerCertificatesResponse {
  bytes certificate_private_key_pkcs8 = 4 [json_name="certificate_private_key_pkcs8"];
  KEYTYPE certificate_private_key_type = 5 [json_name="certificate_private_key_type"];
  repeated CertificateBundle certificate_bundles = 6 [json_name="certificate_bundles"];

  // ClientState data is copied here from the request, if verified, and used to
  // populate the *protocol.Conn, if used
  google.protobuf.Struct client_state = 50 [json_name="client_state"];
}

// ServerLedRegistrationRequest is a request for the "operator-led"
// registration flow. Although currently empty it's required to ensure that we
// can add parameters later without an API change.
message ServerLedRegistrationRequest {
}

// ServerLedActivationToken contains stored information about a
// one-time-use activation token. The ID is created by the actual returned
// token's nonce HMAC'd by the token's keybytes.
message ServerLedActivationToken {
  string id = 1;

  // The time at which this was created; always overwritten on load from
  // creation_time_marshaled
  google.protobuf.Timestamp creation_time = 10 [json_name="creation_time"];

  // This stores a marshaled version of the creation time so that it can easily
  // be wrapped
  bytes creation_time_marshaled = 11 [json_name="creation_time_marshaled"];

  // If set, the key ID of the wrapping key used to encrypt the private keys
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];

  // State is data that the implementor of a Store can use to round-trip data
  // through this library; as an example, a version number on the resource for
  // implementing transactions.
  google.protobuf.Struct state = 50;
}

// ServerLedActivationTokenNonce is the value actually returned to a user.
// The a SHA256-HMAC of the nonce by the key bytes should result in an ID that
// can be found in storage.
message ServerLedActivationTokenNonce {
  bytes nonce = 1;

  bytes hmac_key_bytes = 2 [json_name = "hmac_key_bytes"];
}
