---
layout: docs
page_title: Auditing
description: |-
  An overview of using Boundary to audit for compliance and threat management
---

# Auditing

A fundamental challenge of securing access to sensitive computing resources is creating a system of record around users' access and actions over remote sessions.
Organizations are typically motivated to invest in recording capabilities to address at least one of the following:

1. **Compliance management**: Organizations need to prove compliance of their infrastructure's security posture to internal or external auditors.
Records of remote access are often required.

   Various laws and regulations have record keeping requirements.
   These laws and regulations specify what activities need to be recorded and how long the records must be kept.
   One of the reasons an organization records access to a system is to comply with the record keeping requirements of a law or regulation.

2. **Threat management**: Organizations must monitor, investigate, and react to security incidents and malicious activity.
Further, security teams seek to prevent incidents and proactively identify potential threats in real time.

   In the course of their investigations, security teams may need to identify suspicious activity conducted by a specific principal or against a specific target.
   Administrators may require a breakdown of session information by user or a time-based view of past activities, for example.

## Session recording

Boundary provides auditing capabilities via [session recording](/boundary/docs/concepts/domain-model/session-recordings).
In Boundary, a session represents a set of connections between a user and a host from a target.
The session begins when an authorized user requests access to a target, and it ends when that access is terminated.
All sessions have a fixed time limit, and all connections are proxied through a worker.

Sessions are recorded by workers.
Workers are the proxy between an end user and a target.
No session data is routed through a controller during the recording stage.
The worker stores the session recording on local disk during the recording phase, and then moves the recording to the external object store when the session is terminated. Session recordings are stored in the [BSR](#bsr-directory-structure) (Boundary Session Recording) format.
Any credentials needed to access the external object store are passed from the controller to the recording worker when the session is established.

In a multi-hop session, the worker that is configured to access the external object store is the worker that records the session.
If no worker can access the storage backend, the session is canceled and an error is returned.

You view session recordings with a session player that runs in a web browser.
The session player is an aggregation of web components that work together to present the different parts of a session recording as a logical whole.
A controller retrieves the contents of a recording from a worker with access to the external object store.
The controller decodes the contents of the recording into a format that is usable by the player.
The player then retrieves the data from the controller.

## Storage buckets

A resource known as a [storage bucket](/boundary/docs/concepts/domain-model/storage-buckets) is used to store the recorded sessions.
The storage bucket represents a bucket in an external object store.
At this time, the only supported storage for storage buckets is AWS S3.
In AWS S3, a storage bucket contains the bucket name, region, and optional prefix, as well as any credentials needed to access the bucket, such as the secret key.

Before you can use a storage bucket to record sessions, you must configure a worker with local storage to act as a cache.
The entire recording is written to the local storage cache before it is uploaded.
Once the session is complete, the files are automatically synced with the external storage bucket and deleted from the worker's local storage.

A storage bucket exists in either the Global scope or an Org scope.
A storage bucket that is associated with the Global scope can be associated with any target.
However, a storage bucket in an Org scope can only be associated with targets in a project from the same Org scope.
Any storage buckets associated with an Org scope are deleted when the Org itself is deleted.

Deleting a storage bucket in Boundary does not delete the bucket in the external object store, nor does it delete the recorded sessions in the bucket.
The storage bucket's lifecycle does not affect the lifecycle of the bucket in the external object store.
Any session recording metadata that is attached to the storage bucket is deleted when the storage bucket is deleted.

## BSR directory structure

The BSR (Boundary Session Recording) defines a hierarchical directory structure of files and a binary file format.
It contains all the data transmitted between a user and a target during a single session.

Boundary creates the top-level directory of the BSR as `<sessionID>.bsr`. This top level directory contains session summary information and subdirectories for connections.

A BSR connections directory contains a summary of connections, as well as inbound and outbound requests.
If you use a multiplexed protocol, there are subdirectories for the channels.

```
└── sr_iNCdGSREeX.bsr
    ├── SHA256SUM
    ├── SHA256SUM.sig
    ├── bsrKey.pub
    ├── cr_3bB78W53Y9.connection
    │   ├── SHA256SUM
    │   ├── SHA256SUM.sig
    │   ├── chr_VUnVuVnITu.channel
    │   │   ├── SHA256SUM
    │   │   ├── SHA256SUM.sig
    │   │   ├── channel-recording-summary.json
    │   │   ├── channel-recording.meta
    │   │   ├── messages-inbound.data
    │   │   ├── messages-outbound.data
    │   │   ├── requests-inbound.data
    │   │   └── requests-outbound.data
    │   ├── chr_nITuVUnVuV.channel
    │   │   ├── SHA256SUM
    │   │   ├── SHA256SUM.sig
    │   │   ├── channel-recording-summary.json
    │   │   ├── channel-recording.meta
    │   │   ├── messages-inbound.data
    │   │   ├── messages-outbound.data
    │   │   ├── requests-inbound.data
    │   │   └── requests-outbound.data
    │   ├── connection-recording-summary.json
    │   ├── connection-recording.meta
    │   ├── requests-inbound.data
    │   └── requests-outbound.data
    ├── cr_W53Y93bB78.connection
    │   ├── SHA256SUM
    │   ├── SHA256SUM.sig
    │   ├── chr_uVVuUITnVn.channel
    │   │   ├── SHA256SUM
    │   │   ├── SHA256SUM.sig
    │   │   ├── channel-recording-summary.json
    │   │   ├── channel-recording.meta
    │   │   ├── messages-inbound.data
    │   │   ├── messages-outbound.data
    │   │   ├── requests-inbound.data
    │   │   └── requests-outbound.data
    │   ├── connection-recording-summary.json
    │   ├── connection-recording.meta
    │   ├── requests-inbound.data
    │   └── requests-outbound.data
    ├── pubKeyBsrSignature.sign
    ├── pubKeySelfSignature.sign
    ├── session-meta.json
    ├── session-recording-summary.json
    ├── session-recording.meta
    ├── wrappedBsrKey
    └── wrappedPrivKey
```

## Validating the Integrity of Session Recordings

BSR directories are validated based on the contents in the directory.
Boundary cryptographically verifies each individual Boundary Session Recording (BSR) file. The keys used for verifying all
Boundary Session Recording files are written to storage and are wrapped by your configured KMS. Each Session Recording will
have its own individual key. The following keys will be generated when a Session Recording is authorized:

- BSR Key: AES-GCM used for signing the public key.

- Private/Public key pair: ed25519 key pair.  Private key is used to sign BSR files: initially the public key and the BSR checksums file. 

The BSR’s key and the derived key-pair will be written to storage beside all the other BSR files.
Encrypting the BSR key with an external KMS means that Boundary is not responsible for the longevity of the keys.
The Boundary admin can always use that external KMS they control to decrypt BSR keys. 
A BSR’s key will be encrypted using the `go-kms-wrapping` package and therefore the encrypted BlobInfo will include the metadata required to identify the key-version used during encryption,
so if the wrapper is reinitialized properly; the keys can be unwrapped even if the key has been rotated.  
Users can use `go-kms-wrapping` independently from Boundary to unwrap the BSR keys as needed.

Each BSR directory contains a SHA256SUM and SHA256SUM.sign file that can be used to cryptographically verify the BSR directory's contents.
The SHA256SUM file contains rows of file names paired with a checksum for the file contents.
The SHA256SUM.sign is a copy of the SHA256SUM file, signed with the BSR's private key.
An example of the SHA256SUM file:

   ```
   dc8ce2c42553ce510197c99efe21d89d6229feb4b49170511f49965f2e3cf1a3  wrappedBsrKey
   a5a91b1b52fb53c4bab661b2e5846bb2a836f050e3d745e436078871914a0bc2  wrappedPrivKey
   1ca281852ec0d447b94708f28a51b562d47b84affdba25e13a97b0fbd9126424  pubKeyBsrSignature.sign
   7b5e18e5930bb4cce12a3f203328d9065cae29f26aba3963bb5faece2cf97231  pubKeySelfSignature.sign
   dc7c6b1316624c7c486a22bab157f947df92b9f2ce4a72469b1f335399a043d5  bsrKey.pub
   4d3966c458f4e5d67f9ac70b804540b927c718965267c3f36526bf0b18c40ad9  session-meta.json
   6fec2173d331828677fb5e77fc19168daad3c5f0e82517a82e5701e6c2bdcbe1  session-recording.meta
   ad76483e7cf3e65391a3a1d0b86a3ad436333ee225bea042b13900abc188b226  session-recording-summary.json
   ```

Workers will use these keys to sign BSR data as follows:

- The BSR key will be used to sign the public key using `go-kms-wrapping` package HmacSha256(...)

- The private key will be used to sign the public key using `go-kms-wrapping` package ed25519.Sign(...)

- The private key will be used to sign the BSR SHA256SUM file using `go-kms-wrapping` package ed25519.Sign(...)

Workers will use these keys to verify BSR data as follows:

- The BSR key or the private key can be used to verify the public key using `go-kms-wrapping` HmacSha256(...)

- Once verified, the public key can be used to verify the BSR SHA256SUM file using `go-kms-wrapping` ed25519.Sign(...)

## Validating the Data Integrity in the External Object Store

When a Boundary worker is uploading a BSR file to AWS S3 through the Boundary AWS Plugin, the worker calculates the SHA256 checksum of the
contents of the BSR file and attaches this information to the object that is uploaded to S3. The stored SHA256 checksum value can now be used
to validate the contents of the BSR file when downloading it from AWS S3 through the Boundary AWS Plugin. This process ensures that
no tampering of BSR files occurs between the worker, plugin, and S3.

For more information, refer to the [overview of configuring session recording](/boundary/docs/configuration/session-recording).
